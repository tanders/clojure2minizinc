* clojure2minizinc

** Summary

   A Clojure library designed to solve constraint satisfaction problems (CSP). It generates [[www.minizinc.org][MiniZinc]] code from Clojure code, that is very similar to the corresponding MiniZinc code. The generated MiniZinc program is then solved by one of the MiniZinc solvers available (e.g., see http://www.minizinc.org/software.html), and the result is read back into Clojure.


** TODO What is MiniZinc and why clojure2minizinc?


** TODO Installation 

   - Installation of MiniZinc tools
     - Install the [[http://www.minizinc.org/g12distrib.html][G12 MiniZinc Distribution]] (includes translation of MiniZinc to intermediate simpler format FlatZinc, which is understood by many solvers, but also ready-to-use solvers)
     - Additional solvers (optional), e.g., see FlatZinc Implementations at http://www.minizinc.org/software.html

   - Installation of this library
     TODO: get installation with =lein= working


** TODO Usage 


*** TODO A Minimal Example 

    TODO: Revise: update if necessary (e.g., =clj2mnz= will likely be gone later). 

#+begin_src clojure :results silent
(minizinc 
   (clj2mnz
    (let [a (variable (-- -1 1)) 
          b (variable (-- -1 1))]
      (constraint (!= a b))
      (solve :satisfy)
      (output-map {:a a :b b})))
   :num-solutions 3
   ;; :all-solutions? true
   )
#+end_src

    Results in =({:a 0, :b -1} {:a 1, :b -1} {:a -1, :b 0})=.
    
    Generates in the background this MiniZinc code and calls solver with it
    
    Note that this library overwrites many standard Clojure functions. You may want to use the library with a namespace prefix.

*** Further Reading 


** Similarity  and differences between MiniZinc and its Clojure complement

   Definitions in clojure2minizinc can be very similar to MiniZinc code. This sections lists important differences.


*** Code similarity

   In clojure2minizinc all code is expressed by standard Lisp S-expressions. Most MiniZinc operators, functions etc. are called exactly the same in clojure2minizinc. For example the following two code snippets show a MiniZinc code line and the corresponding clojure2minizinc 

#+begin_src minizinc :results silent
constraint x + y != z;
#+end_src

#+begin_src clojure :results silent
(constraint (!= (+ x y) z))
#+end_src

   Because of this similarity of code, the main documentation of clojure2minizinc is actually the MiniZinc documentation. For example, the [[http://www.minizinc.org/downloads/doc-latest/minizinc-tute.pdf][MiniZinc tutorial]] is also a useful documentation for this library. 

   *TODO* add links to further MiniZinc documentation


*** Exceptions to the similarity

    There are a few exceptions, where certain MiniZinc operator etc. names cannot be translated into Clojure due to certain restrictions of Clojure. These are listed below (first MiniZinc, then the corresponding Clojure function name of this library).

    *TODO* full (short) list of different function names: 
     - =var= is =variable=
     - =..= is =--=
     - =/\= is =and=
     - =\/= is =or=


**** Temporary differences

     An equivalent for the MiniZinc =output= does not exist, use =output-map= instead.


*** Going beyond MiniZinc limitations
    
    clojure2minizinc allows to do a number of things that are impossible in plain MiniZinc. Particular important is the fact that decision variables can be stored in arbitrary Clojure data structures, and then constraints be applied to these data structures. MiniZinc does not see the Clojure data structure, but it may help to express information about the constraint problem to model (e.g., to express how certain variables are related).  

    *TODO* Demo example

    In addition, most Clojure functionality is available for defining MiniZinc models. For example, auto-completion and documentation of your editor will help you (standard MiniZinc editors do not support anything like that).

    combination with any other Clojure [features]
    IO
    GUI


*** TODO Limitations compared to standard Clojure programming 

    Constraint programming provides a very high level of abstraction for the programmer. However, this strength comes with a certain price. In particular, 
...

software using constraint programming is harder to debug.
 


** Design 

   Most Clojure functions simply generate a string with the corresponding MiniZinc code. So, this library is very easy to extend to support not only the full feature set of MiniZinc, but also MiniZinc extensions proposed by various research projects.

   The downside is that debugging the Clojure programs is somewhat difficult. For example, error messages by MiniZinc refer to line numbers of the generated MiniZinc code. However, constraint problem debuggers are not too helpful anyway. A useful technique is usually to disable all constraints for testing and then by and by enabling them again. 
 

** License

Copyright Â© 2014 Torsten Anders

Distributed under the GNU General Public License.
