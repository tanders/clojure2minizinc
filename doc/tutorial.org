#+TITLE: A Tutorial Introducing =clojure2minizinc=
#+AUTHOR: Torsten Anders

#+PROPERTY: header-args :results silent

# NOTE: title and author ignored in GitHub rendering and also when translating with PanDoc to Markdown

# Doc: see http://orgmode.org/worg/org-contrib/babel/languages/ob-doc-clojure.html
# Within org buffer start cider: M-x cider-jack-in RET

#+PROPERTY: header-args:clojure  :session *clojure-1*

* Motivation 

The present [[http://clojure.org/][Clojure]] library clojure2minizinc provides a MiniZinc interface for Clojure. [[http://www.minizinc.org/][MiniZinc]] is a domain-specific language (DSL) for modelling constraint satisfaction and optimisation problems (CSP) over Boolean, integer, real number, and set variables. 

MiniZinc has the potential to become the lingua franca of the Constraint Programming community. For developers of existing constraint solvers it is rather easy to define a MiniZinc interface for their solvers, [[http://www.minizinc.org/software.html][several state-of-the-art solvers already support MiniZinc]] via the simpler language FlatZinc (even more solvers listed [[http://www.hakank.org/minizinc/][here]]), and they compete in a yearly [[http://www.minizinc.org/challenge.html][MiniZinc Challenge]].  


** Advantages over using MiniZinc directly

In clojure2minizinc, CSPs can be defined directly in Clojure in a way very similar to MiniZinc. MiniZinc (and its constraint solvers, including 3rd-party solvers) do the actual work in the background, and the result is read back into Clojure. 

Because using clojure2minizinc can be so close to using MiniZinc itself, this tutorial complements the [[http://www.minizinc.org/downloads/doc-latest/minizinc-tute.pdf][MiniZinc tutorial]]: its examples are translated into Clojure here. Even the same headlines are used, so that both tutorials can be read in parallel. In addition to the translated examples, this tutorial primarily explains the differences between clojure2minizinc and MiniZinc.


Additionally, facilities of Clojure can be used for defining CSPs, and for processing the results.

MiniZinc is a highly specialised language and relatively small language. It lacks many features of standard programming languages. clojure2minizinc marries MiniZinc with Clojure and that way many concepts of general purpose languages (in the guise of their Clojure implementation) can be used for a MiniZinc program.

For example, a clojure2minizinc program is defined in a Clojure namespace. The following code block defines a namespace for this tutorial, and loads clojure2minizinc definitions under the alias =mz= (for MiniZinc).

#+begin_src clojure :results silent
(ns clojure2minizinc.tutorial
  (:require [clojure2minizinc.core :as mz] ; 
            [clojure.pprint :as pprint]))
#+end_src




* Basic Modelling in MiniZinc

** Our First Example

The first example defines a map-colouring of Australia. The [[http://www.minizinc.org/downloads/doc-latest/minizinc-tute.pdf][MiniZinc tutorial]], p. 3ff, motivates and explains this model. (This tutorial assumes that you read the MiniZinc tutorial alongside.) 

Notice that most functions in this example are in the =mz= namespace, but the decision variables (and an int) of the model are stored with the standard Clojure =let= form -- clojure2minizinc allows to store MiniZinc variables and parameters (constants) in arbitrary Clojure data structures.

#+begin_src clojure 
(def aust
  (mz/clj2mnz
   (let [nc (mz/int 'nc 3)              ; number of colours
         wa (mz/variable (mz/-- 1 nc))  ; 7 variables for 7 states
         nt (mz/variable (mz/-- 1 nc))
         sa (mz/variable (mz/-- 1 nc))
         q (mz/variable (mz/-- 1 nc))
         nsw (mz/variable (mz/-- 1 nc))
         v (mz/variable (mz/-- 1 nc))
         t (mz/variable (mz/-- 1 nc))]
     (mz/constraint (mz/!= wa nt))
     (mz/constraint (mz/!= wa sa))
     (mz/constraint (mz/!= nt sa))
     (mz/constraint (mz/!= nt q))
     (mz/constraint (mz/!= sa q))
     (mz/constraint (mz/!= sa nsw))
     (mz/constraint (mz/!= sa v))
     (mz/constraint (mz/!= nsw v))
     (mz/solve :satisfy)
     (mz/output-map {:wa wa :nt nt :sa sa :q q :nsw nsw :v v :t t}))))
#+end_src

We can solve this MiniZinc model as follows.

#+begin_src clojure 
(mz/minizinc aust)
#+end_src

It returns the following result. Different numbers encode different colours on the map for the Australian states.

  =; => ({:wa 1, :nt 2, :sa 3, :q 1, :nsw 2, :v 1, :t 1})=

In this example, a solution is wrapped in a Clojure map. You can ask for multiple solutions, if you like. 

#+begin_src clojure 
(mz/minizinc aust :num-solutions 3)
#+end_src

  =; => ({:wa 1, :nt 2, :sa 3, :q 1, :nsw 2, :v 1, :t 1} {:wa 2, :nt 1, :sa 3, :q 2, :nsw 2, :v 1, :t 1} {:wa 1, :nt 3, :sa 2, :q 1, :nsw 3, :v 1, :t 1})=


*** The Resulting MiniZinc Code

The var =aust= binds a string created by the model above. This string is shown below (without surrounding double-quotes for simplicity). 

#+begin_example
int: nc = 3;
var 1..nc: var4570;
var 1..nc: var4571;
var 1..nc: var4572;
var 1..nc: var4573;
var 1..nc: var4574;
var 1..nc: var4575;
var 1..nc: var4576;
constraint (var4570 != var4571);
constraint (var4570 != var4572);
constraint (var4571 != var4572);
constraint (var4571 != var4573);
constraint (var4572 != var4573);
constraint (var4572 != var4574);
constraint (var4572 != var4575);
constraint (var4574 != var4575);
solve satisfy;
output ["{", " :wa ", show(var4570), " :nt ", show(var4571), " :sa ", show(var4572), " :q ", show(var4573), " :nsw ", show(var4574), " :v ", show(var4575), " :t ", show(var4576), "}\n"];
#+end_example

The string contains the generated MiniZinc code. Note the similarity between the model in Clojure and in MiniZinc. clojure2minizinc aims to be very similar to MiniZinc itself, so that the MiniZinc documentation can also document clojure2minizinc. Nevertheless, some differences are unavoidable. Obviously, clojure2minizinc uses Clojure syntax, and some functions names are illegal in Clojure (e.g., =var= is a special form, and clojure2minizinc must define the function =variable= instead).

The generated code is almost exactly the same as the MiniZinc model =aust.mzn= shown in Figure 2 of the tutorial, p. 4. The main difference is that the variable names in the code above are generated automatically (the names may look slightly different when you run this code). The function =mz/variable= simply does not know that its result is stored in a symbol by =let=, and thus does not know its name. If you are only interested in the Clojure code, this poses no problem, as you do not need to read the automatically generated MiniZinc variables.  

If you want better readable MiniZinc code, just explicitly tell =mz/variable= (or its friends like =mz/int=) your MiniZinc variable name. 

#+begin_src clojure 
(mz/variable (mz/-- 1 10) 'x)
#+end_src


*** Storing Variables in Other Data Structures 

As mentioned above, clojure2minizinc can store MiniZinc variables and parameters in arbitrary Clojure data structures. The following example stores the variables for the colours of Australian states in a map. The same inequality constraints are applied by mapping over pairs of keywords representing these inequalities somewhat more concisely. 

#+begin_src clojure 
(mz/minizinc 
 (mz/clj2mnz
  (let [nc (mz/int 'nc 3)
        states (zipmap [:wa :nt :sa :q :nsw :v :t]
                       (take 7 (repeatedly #(mz/variable (mz/-- 1 nc)))))]
    (doall (map (fn [[s1 s2]] 
                  (mz/constraint (mz/!= (s1 states) (s2 states))))
                [[:wa :nt] [:wa :sa] [:nt :sa] [:nt :q] [:sa :q] [:sa :nsw] [:sa :v] [:nsw :v]]))
    (mz/solve :satisfy)
    (mz/output-map states))))
#+end_src

The resulting MiniZinc code is basically the same, and thus also the result.


** An Arithmetic Optimisation Example

The MiniZinc tutorial, p. 6ff, continues with an optimisation example, that computes the number of banana (=b=) and chocolate (=c=) cakes to bake for maximum profit given the recipes for these cakes, the amount of ingredients, and the price at which each cake can be sold. 

The corresponding clojure2minizinc code is shown below. Please see the MiniZinc tutorial for an explanation of this model. 

#+begin_src clojure
(mz/minizinc 
 (mz/clj2mnz
  (let [b (mz/variable (mz/-- 1 100))
        c (mz/variable (mz/-- 1 100))]
    ;; flour
    (mz/constraint (mz/<= (mz/+ (mz/* 250 b)
                                (mz/* 200 c))
                          4000))
    ;; bananas
    (mz/constraint (mz/<= (mz/* 2 b) 6))
    ;; sugar
    (mz/constraint (mz/<= (mz/+ (mz/* 75 b)
                                (mz/* 150 c))
                          2000))
    ;; butter 
    (mz/constraint (mz/<= (mz/+ (mz/* 100 b)
                                (mz/* 150 c))
                          500))
    ;; cocoa
    (mz/constraint (mz/<= (mz/* 75 c) 500))
    ;; maximise profit
    (mz/solve :maximize (mz/+ (mz/* 400 b) (mz/* 450 c)))
    (mz/output-map {:banana-cakes b :chocolate-cakes c}))))
#+end_src

The optimal solution are two cakes of each kind. 

  =; => ({:banana-cakes 2, :chocolate-cakes 2})=


** Datafiles and Assertions

In the previous example, the amount of each ingredient was fixed in the model. MiniZinc supports parameterising models, usually with MiniZinc data files. 

The clojure2minizinc version of the parameterised model is shown below. Again, please see the MiniZinc tutorial (p. 8ff) for an explanation of this model. 

#+begin_src clojure
(def cakes2
  (mz/clj2mnz
   (let [flour (mz/int :flour)
         banana (mz/int :banana)
         sugar (mz/int :sugar)
         butter (mz/int :butter)
         cocoa (mz/int :cocoa)]
     (mz/constraint (mz/assert (mz/>= flour 0) "Amount of flour must not be negative"))
     (mz/constraint (mz/assert (mz/>= banana 0) "Amount of banana must not be negative"))
     (mz/constraint (mz/assert (mz/>= sugar 0) "Amount of sugar must not be negative"))
     (mz/constraint (mz/assert (mz/>= butter 0) "Amount of butter must not be negative"))
     (mz/constraint (mz/assert (mz/>= cocoa 0) "Amount of cocoa must not be negative"))
     (let [b (mz/variable (mz/-- 1 100))
           c (mz/variable (mz/-- 1 100))]
       ;; flour
       (mz/constraint (mz/<= (mz/+ (mz/* 250 b)
                                   (mz/* 200 c))
                             flour))
       ;; bananas
       (mz/constraint (mz/<= (mz/* 2 b) banana))
       ;; sugar
       (mz/constraint (mz/<= (mz/+ (mz/* 75 b)
                                   (mz/* 150 c))
                             sugar))
       ;; butter 
       (mz/constraint (mz/<= (mz/+ (mz/* 100 b)
                                   (mz/* 150 c))
                             butter))
       ;; cocoa
       (mz/constraint (mz/<= (mz/* 75 c) cocoa))
       ;; maximise profit
       (mz/solve :maximize (mz/+ (mz/* 400 b) (mz/* 450 c)))
       (mz/output-map {:banana-cakes b :chocolate-cakes c})))))
#+end_src


In clojure2minizinc, the parameters for a model are given directly to the solver. The code below specifies the same amounts of ingredients for the cakes as the original example, and therefore the result is the same. 

#+begin_src clojure 
(mz/minizinc cakes2
  :data (mz/map2minizinc {:flour 4000 :banana 6 :sugar 2000 :butter 500 :cocoa 500}))
#+end_src

  =; => ({:banana-cakes 2, :chocolate-cakes 2})=

Different amounts have a different optimal result.

#+begin_src clojure 
(mz/minizinc cakes2
  :data (mz/map2minizinc {:flour 8000 :banana 11 :sugar 3000 :butter 1500 :cocoa 800}))
#+end_src

  =; =>  ({:banana-cakes 3, :chocolate-cakes 8})=

#+RESULTS:


#+begin_src clojure 

#+end_src



#+begin_src clojure 

#+end_src



#+begin_src clojure 

#+end_src

#+begin_src clojure

#+end_src


* COMMENT Similarity and differences between MiniZinc and clojure2minizinc

  Definitions in clojure2minizinc can be very similar to MiniZinc code. This sections lists important differences.


** Code similarity

   In clojure2minizinc all code is expressed by standard Lisp S-expressions. Most MiniZinc operators, functions etc. are called exactly the same in clojure2minizinc. For example the following two code snippets show a MiniZinc code line and the corresponding clojure2minizinc (without namespace prefixes).

#+begin_src minizinc :results silent
constraint x + y != z;
#+end_src

#+begin_src clojure :results silent
(constraint (!= (+ x y) z))
#+end_src

   Because of this similarity of code, the main documentation of clojure2minizinc is actually the MiniZinc documentation. For example, the [[http://www.minizinc.org/downloads/doc-latest/minizinc-tute.pdf][MiniZinc tutorial]] is also a useful documentation for this library. 

   *TODO* add links to further MiniZinc documentation


** Exceptions to the similarity

   There are a few exceptions, where certain MiniZinc operator etc. names cannot be translated into Clojure due to certain restrictions of Clojure. These are listed below (first MiniZinc, then the corresponding Clojure function name of this library).

   *TODO* full (short) list of different function names: 
    - =var= is =variable=
    - =..= is =--=
    - =/\= is =and=
    - =\/= is =or=
    - =not= is =nega=
    - =forall= syntax is "clojurized"


*** Temporary differences

    An equivalent for the MiniZinc =output= does not exist, use =output-map= instead.


** Going beyond MiniZinc limitations
    
    clojure2minizinc allows to do a number of things that are impossible in plain MiniZinc. Particular important is the fact that decision variables can be stored in arbitrary Clojure data structures, and then constraints be applied to these data structures. MiniZinc does not see the Clojure data structure, but it may help to express information about the constraint problem to model (e.g., to express how certain variables are related).  

    *TODO* Demo example

    clojure2minizinc also allows for higher-order programming, such as mapping of MiniZinc records translated into Clojure sequences. 

#+begin_src clojure :results silent
(map (fn [element] (mz/constraint (mz/< (mz/+ element 1) 10)))
     (mz/array->clj-seq (mz/array (mz/-- 1 3) :bool)))
#+end_src


    In addition, most Clojure functionality is available for defining MiniZinc models. For example, auto-completion and documentation of your editor will help you (standard MiniZinc editors do not support anything like that).

    combination with any other Clojure [features]
    IO
    GUI
    
    


** TODO Limitations compared to standard Clojure programming 

    Constraint programming provides a very high level of abstraction for the programmer. However, this strength comes with a certain price. In particular, 
...

software using constraint programming is harder to debug.
 


